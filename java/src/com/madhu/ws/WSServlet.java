
package com.madhu.ws;

import java.io.IOException;
import java.io.PrintWriter;
import java.security.Principal;
import java.util.HashMap;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * This servlet is the HTTP front end for dynamic Web services.
 * This servlet and supporting classes greatly simplify development
 * of the server side of Web Services with SOAP bindings. After
 * some minimal configuration,
 * 
 * Configuration steps:
 * 
 * 1. Add entries in web.xml, e.g.
 *
 *  <servlet>
 *      <description>
 *      </description>
 *      <display-name>WSServlet</display-name>
 *      <servlet-name>WSServlet</servlet-name>
 *      <servlet-class>com.madhu.ws.proxy.WSServlet</servlet-class>
 *      <init-param>
 *          <description>
 *          Whitespace delimited list of classes
 *          </description>
 *          <param-name>serviceClasses</param-name>
 *          <param-value>
 *          com.madhu.ws.proxy.test.MathService
 *          com.madhu.ws.proxy.test.TestService
 *          </param-value>
 *      </init-param>
 *  </servlet>
 *  <servlet-mapping>
 *      <servlet-name>WSServlet</servlet-name>
 *      <url-pattern>WS/*</url-pattern>
 *  </servlet-mapping>
 *  
 * 2. The serviceClasses parameter can contain any number of service
 *    class names. Each implemention class can optionally extend
 *    com.madhu.ws.proxy.RestrictedService, in which case,
 *    security access restrictions will be enforced. RestrictedService
 *    subclasses must fill in getAuthorizer() describing the required
 *    Authorizer. Additional methods are available for initialization
 *    and obtaining the client Principal. See RestrictedService for
 *    more information.
 *
 * 3. Configure Servlet filters as needed for security.
 * 
 * The URL for the associated Web service is of the form:
 * 
 *    http://<host>:<port>/<context>/WS/<service-class>
 * 
 * Where <service-class> is the simple name of the service, e.g.
 * 
 *    http://localhost:9080/WebServiceProxy/WS/MathService
 * 
 * Note that the service package name is not included in the URL.
 * 
 * If the service name is left out, the servlet will return a human
 * readable HTML page listing all registered services and links to
 * their respective WSDL document. The WSDL for a service can be
 * obtained by adding "wsdl" as the query string, e.g.
 * 
 *    http://localhost:9080/WebServiceProxy/WS/MathService?wsdl
 * 
 * This servlet will expose any public methods defined in a service
 * class with the exception of init(...) and getAuthorizor().
 * 
 * Arguments and return values for service methods can include
 * primitive types, arrays, or Serializable classes. Any value objects
 * used in arguments and return values must define a public zero
 * argument constructor (or no constructors at all).
 * 
 * Currently, only non-transient instance fields of value objects are
 * serialized. Super class fields are also serialized, but the resulting
 * client class as described in the WSDL and generated by most Web
 * Service tools will combine all fields into one class. Effectively,
 * the subclass and all superclasses are combined into one. This should
 * have little or no effect other than a minor difference in server and
 * client side class definitions.

 * 
 * Names of method arguments are not automatically reflected from the
 * source. These can be specified using the @ParameterNames annotation
 * before any exposed method:
 * 
 *  @ParameterNames("a,b")
 *  public double min(double a, double b) {
 *      return Math.min(a, b);
 *  }
 * 
 * The @ParameterNames annotation defines a comma separated list of
 * argument names, one for each argument.
 * 
 * If @ParameterNames is not present, argument names take the form arg0,
 * arg1, arg2 etc. The arguement names are used in the generated WSDL,
 * which can be used to generate a client. The use of @ParametersNames
 * annotation will produce more user friendly client code.
 * 
 * The name space for the Web Service is the reverse package name of
 * the service class prepended with "client.". The package name of the
 * client generated from the corresponding WSDL will be the package
 * name of the service appended with ".client". This was done to avoid
 * accidentally overwriting service classes when generating client code.
 * 
 * For example, if the package name of a service is
 * 
 *   com.madhu.ws.proxy.test
 * 
 * The namespace for the Web Service will be
 * 
 *   http://client.test.proxy.ws.madhu.com
 * 
 * The default package name for the generated client will be
 * 
 *   com.madhu.ws.proxy.test.client
 * 
 * Of course, an alternate package name can be specified when the client
 * code is generated. The package name above is simply the default.
 */
 public class WSServlet extends HttpServlet {
	private static final long serialVersionUID = 2432753767512075318L;
	private static final String SERVICE_CLASSES_PARAM = "serviceClasses";
	private HashMap<String, ServiceDescriptor> services;

    /* (non-Java-doc)
	 * @see javax.servlet.http.HttpServlet#HttpServlet()
	 */
	public WSServlet() {
	}
	
	@Override
	public void init() throws ServletException {
		services = new HashMap<String, ServiceDescriptor>();
		String mappings = getInitParameter(SERVICE_CLASSES_PARAM);
		if (mappings != null) {
			String[] classNames = mappings.split("[\\s]+");
//			if (classNames.length == 0) {
//				classNames = new String[]{mappings.trim()};
//			}
			for (String name : classNames) {
				try {
					ServiceDescriptor sd = new ServiceDescriptor(name);
					services.put(sd.getSimpleName(), sd);
				} catch (Exception e) {
					log("Can't load class: " + name);
				}
			}
		}
	}

	/* (non-Java-doc)
	 * @see javax.servlet.http.HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doPost(request, response);
	}
	
	/* (non-Java-doc)
	 * @see javax.servlet.http.HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String pathInfo = request.getPathInfo();
		if (pathInfo == null || pathInfo.length() <= 1) {
			doHTML(request, response);
			return;
		}
		String serviceURL = String.format("%s://%s:%d%s%s%s",
				request.getScheme(),
				request.getServerName(),
				request.getServerPort(),
				request.getContextPath(),
				request.getServletPath(), pathInfo);
		int slash = pathInfo.lastIndexOf('/');
		if (slash < 0 || slash >= pathInfo.length()-1) {
			doHTML(request, response);
			return;
		}
		String serviceName = pathInfo.substring(slash+1);
		ServiceDescriptor desc = services.get(serviceName);
		if (desc == null) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No such service: " + serviceName);
			return;
		}
		try {
			String qs = request.getQueryString();
			if (qs != null && qs.trim().equals("wsdl")) {
				response.setContentType("text/xml");
				WSDLGenerator wsdl = new WSDLGenerator(desc, serviceURL);
				wsdl.generateWSDL();
				wsdl.writeXMLTo(response.getOutputStream());
				return;
			}

			SOAPProxy soap = new SOAPProxy(desc, request.getInputStream());
			Object object = desc.getImplementation().newInstance();

			Principal principal = request.getUserPrincipal();
			if (!isAuthorized(object, soap.getMethodName(), principal)) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN,
					String.format("You are not authorized to access %s.%s",
							desc.getImplementation().getName(), soap.getMethodName()));
				return;
			}

			if (object instanceof RestrictedService) {
				RestrictedService ao = (RestrictedService) object;
				ao.setPrincipal(principal);
			}

			soap.invoke(object);
			response.setContentType("text/xml");
			soap.writeXMLTo(response.getOutputStream());
		} catch (Exception e) {
			log(e.getMessage(), e);
			response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.toString());
		}
	}

	/**
	 * The gatekeeper method. Fill in the implementation as needed.
	 * 
	 * @param service - The class that implements a web service
	 * @param methodName - The method name called by the client
	 * @param principal - The client principal (user name)
	 * @return true if authenticated and authorized to call the method in the implementation
	 */
	private boolean isAuthorized(Object service, String methodName, Principal principal) {
		return true;
	}

	private void doHTML(HttpServletRequest request, HttpServletResponse response) throws IOException {
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("<html><head>" +
				"<style>body{font-family:arial,sans-serif}</style>" + 
				"<title>WSServlet</title></head><body>");
		out.println(String.format("<h3>There are %d web services here</h3>", services.keySet().size()));
		out.println("<table border=\"1\">");
		out.println("<tr><th>URI</th><th>Implementation</th><th>Namespace</th><th>WSDL</th></tr>");
		for (String key : services.keySet()) {
			ServiceDescriptor desc = services.get(key);
			out.println(String.format("<tr><td>%s%s/%s</td><td>%s</td><td>%s</td>" +
					"<td><a href=\"%s%s/%s?wsdl\">WSDL</a></td>" +
					"</tr>",
					request.getContextPath(), request.getServletPath(), key,
					desc.getClass().getName(), desc.getNameSpace(),
					request.getContextPath(), request.getServletPath(), key));
		}
		out.println("</table>");
		out.println("</body></html>");
	}
}
